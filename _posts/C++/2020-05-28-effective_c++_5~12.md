---
layout: post
title: "[Effective C++]생성자, 소멸자 및 대입 연산자"
description: >
    [Effective C++]책 요약 - 이것만은 잊지 말자 항목 5~12
author: author1
tags: [C++]
category: [C++]
---

#### __항목 5: c++가 은근슬쩍 만들어 호출해 버리는 함수들에 촉각을 세우자__  
- 컴파일러는 경우에 따라 클래스에 대한 기본 생성자, 복사 생성자 복사 대입 연산자, 소멸자를 암시적으로 만들어 놓을 수 있다.  

#### __항목 6: 컴파일러가 만들어낸 함수가 필요 없으면 확실히 이들의 사용을 금해 버리자__  
- 컴파일러에서 자동으로 제공하는 기능을 허용치 않으려면, 대응되는 멤버 함수를 private로 선언한 후에 구현은 하지 않은 채로 두자. Uncopyable과 비슷한 기본 클래스를 쓰는 것도 한 방법이다.  

#### __항목 7: 다형성을 가진 기본 클래스에서는 소멸자를 반드시 가상 소멸자로 선언하자__  
- 다형성을 가진 기본 클래스에는 반드시 가상 소멸자를 선언해야 한다. 즉 어떤 클래스가 가상 함수를 하나라도 갖고 있으면, 이 클래스의 소멸자도 가상 소멸자이어야 한다.  
- 기본 클래스로 설계되지 않았거나 다형성을 갖도록 설계되지 않은 클래스에는 가상 소멸자를 선언하지 말아야 한다.  

#### __항목 8: 예외가 소멸자를 떠나지 못하도록 붙들어 놓자__  
- 소멸자에서는 예외가 빠져나가면 안 된다. 만약 소멸자 안에서 호출된 함수가 예외를 던질 가능성이 있다면, 어떤 예외이든지 소멸자에서 모두 받아낸 후에 삼켜 버리든지 프로그램을 끝내든지 해야 한다.  
- 어떤 클래스의 연산이 진행되다가 던진 예외에 대해 사용자가 반응해야 할 필요가 있다면, 해당 연산을 제공하는 함수는 반드시 보통의 함수(즉, 소멸자가 아닌 함수)이어야 한다.  

#### __항목 9: 객체 생성 및 소멸 과정 중에는 절대로 가상 함수를 호출하지 말자__  
- 생성자 혹은 소멸자 안에서 가상 함수를 호출하지 말자. 가상 함수라고 해도, 지금 실행중인 생성자나 소멸자에 해당되는 클래스의 파생 클래스 쪽으로는 내려가지 않는다.  

#### __항목 10: 대입 연산자는 *this의 참조자를 반환하게 하자__  
- 대입 연산자는 *this의 참조자를 반환하도록 만들어라.  

#### __항목 11: operator=에서는 자기대입에 대한 처리가 빠지지 않도록 하자__  
- operator=을 구현할 때, 어떤 객체가 그 자신에 대입되는 경우를 제대로 처리하도록 만들자. 원본 객체와 복사대상 객체의 주소를 비교해도 되고, 문장의 순서를 적절히 조정할 수도 있으며, 복사 후 맞바꾸기 기번을 써도 된다.  
- 두 개 이상의 객체에 대해 동작하는 함수가 있다면, 이 함수에 넘겨지는 객체들이 사실 같은 객체인 경우에 정확하게 동작하는지 확인해보자.  

#### __항목 12: 객체의 모든 부분을 빠짐없이 복사하자__  
- 