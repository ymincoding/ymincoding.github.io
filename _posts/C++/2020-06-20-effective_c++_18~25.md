---
layout: post
title: "[Effective C++]설계 및 선언"
description: >
    [Effective C++]책 요약 - 이것만은 잊지 말자 항목 18~25
author: Yunmin Cho
tags: [C++]
category: [C++]
---

#### __항목 18: 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자__  
- 좋은 인터페이스는 제대로 쓰기에 쉬우며 엉터리로 쓰기에 어렵다. 인터페이스를 만들 때는 이 특성을 지닐 수 있도록 고민하고 또 고민하자.  
- 인터페이스의 올바른 사용을 이끄는 방법으로는 인터페이스 사이의 일관성 잡아주기, 그리고 기본제공 타입과의 동작 호환성 유지하기가 있다.  
- 사용자의 실수를 방지하는 방법으로는 새로운 타입 만들기, 타입에 대한 연산을 제한하기, 객체의 값에 대해 제약 걸기, 자원 관리 작업을 사용자 책임으로 놓지 않기가 있다.  
- `tr1::shared_ptr`은 사용자 정의 삭제자를 지원한다. 이 특징 때문에 `tr1::shared_ptr`은 교차 DLL문제를 막아 주며, 뮤텍스 등을 자동으로 잠금 해제하는 데(항목 14 참조) 쓸 수 있다.  

#### __항목 19: 클래스 설계는 타입 설계와 똑같이 취급하자__  
- 클래스 설게는 타입 설계이다. 새로운 타입을 정의하기 전에, 이번 항목에 나온 모든 고려사항을 빠짐없이 점검해보자.  

  1. 새로 정의한 타입의 객체 생성 및 소멸은 어떻게 이루어져야 하는가?  
  2. 객체 초기화는 객체 대입과 어떻게 달라야 하는가?  
  3. 새로운 타입으로 만든 객체가 값에 의해 전달되는 경우에 어떤 의미를 줄 것인가?  
  4. 새로운 타입이 가질 수 있는 적법한 값에 대한 제약은 무엇으로 잡을 것인가?  
  5. 기존의 클래스 상속 계통망(inheritance graph)에 맞출 것인가?  
  6. 어떤 종류의 타입 변환을 허용할 것인가?  
  7. 어떤 연산자와 함수를 두어야 의미가 있을까?  
  8. 표준 함수들 중 어떤 것을 허용하지 말 것인가?  
  9. 새로운 타입의 멤버에 대한 접근권한을 어느 족에 줄 것인가?  
  10. '선언되지 않은 인터페이스'로 무엇을 둘 것인가?  
  11. 새로 만드는 타입이 얼마나 일반적인가?  
  12. 정말로 꼭 필요한 타입인가?  

#### __항목 20: '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달' 방식을 택하는 편이 대개 낫다__  
- '값에 의한 전달'보다는 '상수 객체 참조자에 의한 전달'을 선호하자. 대체적으로 효율적일 뿐만 아니라 복사손실 문제까지 막아 준다.  
- 이번 항목에서 다룬 법칙은 기본제공 타입 및 STL 반복자, 그리고 함수 객체 타입에는 맞지 않는다. 이들에 대해서는 '값에 의한 전달'이 더 적합하다.  

#### __항목 21: 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자__  
- 지역 스택 객체에 대한 포인터나 참조자를 반환하는 일, 혹은 힙에 할당된 객체에 대한 참조자를 반환하는 일, 또는 지역 정적 객체에 대한 포인터나 참조자를 반환하는 일은 그런 객체가 두 개 이상 필요해질 가능성이 있다면 절대로 하지 마라!  

#### __항목 22: 데이터 멤버가 선언될 곳은 private 영역임을 명심하자__  
- 