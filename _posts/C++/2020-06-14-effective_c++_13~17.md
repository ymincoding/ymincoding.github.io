---
layout: post
title: "[Effective C++]자원 관리"
description: >
    [Effective C++]책 요약 - 이것만은 잊지 말자 항목 13~17
author: Yunmin Cho
tags: [C++]
category: [C++]
---

#### __항목 13: 자원 관리에는 객체가 그만!__  
- 자원 누출을 막기 위해, 생성자 안에서 자원을 획득하고 소멸자에서 그것을 해제하는 RAII객체를 사용하자.  
- 일반적으로 널리 쓰이는 RAII 클래스는 `tr1::shared_ptr` 그리고 `auto_ptr`이다. 이 둘 가운데 `tr1::shared_ptr`이 복사 시의 동작이 직관적이기 때문에 대개 더 좋다. 반면, `auto_ptr`은 복사되는 객체(원본 객체)를 null로 만들어 버린다.  

#### __항목 14: 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자__  
- RAII객체의 복사는 그 객체가 관리하는 자원의 복사 문제를 안고 가기 때문에, 그 자원을 어떻게 복사하느냐에 따라 RAII 객체의 복사 동작이 결정된다.  
- RAII 클래스에 구현하는 일반적인 복사 동작은 복사를 금지하거나 참조 카운팅을 해 주는 선으로 마무리하는 것이다. 하지만 이 외의 방법들도 가능하니 참고해 두자.  

#### __항목 15: 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자__  
- 실제 자원을 직접 접근해야 하는 기존 API들도 많기 때문에, RAII 클래스를 만들 때는 그 클래스가 관리하는 자원을 얻을 수 있는 방법을 열어 주어야 한다.  
- 자원 접근은 명시적 변환 혹은 암시적 변환을 통해 가능하다. 안전성만 따지면 명시적 변환이 대체적으로 더 낫지만, 고객 편의성을 놓고 보면 암시적 변환이 괜찮다.  

#### __항목 16: new 및 delete를 사용할 때는 형태를 반드시 맞추자__  
- new 표현식에 []를 썼으면, 대응되는 delete 표현식에도 []를 써야한다. 마찬가지로 new 표현식에 []를 안 썼으면, 대응되는 delete 표현식에도 []를 쓰지 말아야 한다.  

#### __항목 17: new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자__  
- new로 생성한 객체를 스마트 포인터로 넣는 코드는 별도의 한 문장으로 만들어라. 이것이 안 되어 있으면, 예외가 발생될 때 디버깅하기 힘든 자원 누출이 초래될 수 있다.  

<br/>
<span style="color: gray"> *출처: 책 <Effective C++>* </span>